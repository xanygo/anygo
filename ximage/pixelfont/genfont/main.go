//  Copyright(C) 2024 github.com/hidu  All Rights Reserved.
//  Author: hidu <duv123+git@gmail.com>
//  Date: 2024-10-25

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"image"
	"log"

	"github.com/xanygo/anygo/ds/xslice"
	"golang.org/x/image/font"
	"golang.org/x/image/font/gofont/gomono"
	"golang.org/x/image/font/opentype"
	"golang.org/x/image/math/fixed"
)

const (
	fontSize     = 48
	width        = fontSize - 18
	height       = fontSize
	startingDotX = 1           // 6
	startingDotY = height - 10 // 28
)

var code = &bytes.Buffer{}
var codeTpl = `
// Code generated by pixelfont/genfont/main.go. DO NOT EDIT.

package pixelfont

var asciiFonts=map[byte]Byte{
`

var chars = flag.String("c", "", "text chars")
var printPixel = flag.Bool("pp", false, "print pixel chars")

func main() {
	flag.Parse()
	var bs []byte
	for c := 33; c <= 126; c++ {
		// for c := 33; c <= 34; c++ {
		bs = append(bs, byte(c))
	}
	if *chars != "" {
		bs = []byte(*chars)
	}
	generate(bs)
}

func generate(bc []byte) {
	code.WriteString(codeTpl)
	for _, bc := range bc {
		pix := getPixel(bc)
		key := fmt.Sprintf("'%c'", bc)
		switch bc {
		case '\'':
			key = `'\''`
		case '\\':
			key = `'\\'`
		}
		code.WriteString(key + " : ")
		code.Write(pix.Bytes())
		code.WriteString(",\n")
	}
	code.WriteString("}\n")
	buf, err := format.Source(code.Bytes())
	if err != nil {
		log.Fatalf("gofmt failed: %v\n code=\n%s\n", err, code.Bytes())
	}
	fmt.Println(string(buf))
}

var face font.Face

func init() {
	f, err := opentype.Parse(gomono.TTF)
	if err != nil {
		log.Fatalf("Parse: %v", err)
	}
	face, err = opentype.NewFace(f, &opentype.FaceOptions{
		Size:    fontSize,
		DPI:     72,
		Hinting: font.HintingNone,
	})
	if err != nil {
		log.Fatalf("NewFace: %v", err)
	}
}

func getPixel(c byte) *Byte {
	dst := image.NewGray(image.Rect(0, 0, width, height))
	d := font.Drawer{
		Dst:  dst,
		Src:  image.White,
		Face: face,
		Dot:  fixed.P(startingDotX, startingDotY),
	}
	d.DrawBytes([]byte{c})

	xStart := width
	xEnd := 0
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			z := dst.GrayAt(x, y).Y >> 6
			if z <= 0 {
				continue
			}
			xStart = min(xStart, x)
			xEnd = max(xEnd, x)
		}
	}

	if xStart > 0 {
		xStart--
	}

	if xEnd < width {
		xEnd++
	}
	if xEnd < width {
		xEnd++
	}

	buf := make([]byte, 0, height*(width+1)*3)
	var rlsList []int
	lastByte := byte('0')
	var lastCount int
	for y := 0; y < height; y++ {
		buf = append(buf, '\t', '\t')
		// for x := 0; x < width; x++ {
		for x := xStart; x < xEnd; x++ {
			z := dst.GrayAt(x, y).Y >> 6
			if z > 0 {
				buf = append(buf, '1')
				if lastByte == '1' {
					lastCount++
				} else {
					rlsList = append(rlsList, -1*lastCount)
					lastByte = '1'
					lastCount = 1
				}
			} else {
				buf = append(buf, '0')
				if lastByte == '0' {
					lastCount++
				} else {
					rlsList = append(rlsList, lastCount)
					lastByte = '0'
					lastCount = 1
				}
			}
			buf = append(buf, ',')
		}
		buf = append(buf, '\n')
	}
	if lastCount > 0 {
		if lastByte == '1' {
			rlsList = append(rlsList, lastCount)
		} else {
			rlsList = append(rlsList, -1*lastCount)
		}
	}
	return &Byte{
		Width:  xEnd - xStart,
		Height: height,
		Pixel:  buf,
		rle:    rlsList,
	}
}

type Byte struct {
	Width  int
	Height int
	rle    []int
	Pixel  []byte
}

func (b *Byte) rleString() string {
	cks := xslice.Chunk(b.rle, 16)
	var buf bytes.Buffer
	for _, ck := range cks {
		buf.WriteString(xslice.Join(ck, ","))
		buf.WriteString(",\n")
	}
	return buf.String()
}

func (b *Byte) Bytes() []byte {
	var buf bytes.Buffer
	buf.WriteString("{\n")
	buf.WriteString(fmt.Sprintf("\tWidth : %d,\n", b.Width))
	buf.WriteString(fmt.Sprintf("\tHeight : %d,\n", b.Height))
	buf.WriteString("\trle : []int{\n")
	buf.WriteString(b.rleString())
	buf.WriteString("},\n")
	if *printPixel {
		buf.WriteString(fmt.Sprintf("\tPixel : []byte{\n"))
		buf.Write(b.Pixel)
		buf.WriteString("\t\t},\n")
	}
	buf.WriteString("\t}")
	return buf.Bytes()
}
